 * File/Directory Manipulation *
List files in current directory:
> ls 
List all files in current dir, including dot files:
> ls -al
Show file name matching <string>:
> ls -al | grep <string>
Change directory:
> cd <dirpath>
Go to $HOME dir:
> cd
Show the current dir:
> pwd

Create a new file (or updating timestamp of a existing file):
> touch <filename>
Delete a file:
> rm <filename>
Delete a dir:
> rm -r <dirname>
Copy a file:
> cp <filename> <new filename>
Copy a dir:
> cp -r <dirname> <new name>
Create a new dir:
> mkdir <new dir name>
Delete a dir only if it is empty:
> rmdir <dirname>
Rename file, or move to a diff dir:
> mv <filename> <new name>
Show dir size. (Linux: Directory Size: du Command):
> du -sh <dirname>

 * Viewing Files *
View a file:
> cat <filename>
View a file by page. Type [q] to exit. Type [h] for other keys. more can also be less; the latter is better:
> cat <filename> | more
View a file. Type [Esc : q] to exit:
> vi <filename>
View the first few lines of a (big) file. (to get a idea what the heck the file contains):
> head <filename>
View the last few lines of a file:
> tail <filename>
View the last few lines of a growing file, updated continuously. Typically used on log files:
> tail -f <filename>
Report what type of file it is:
> file <filename>

 * Locating Commands *
Show if <cmd name> is a shell built-in or standalone program. e.g. type kill. “type” is a bash built-in:
> type <cmd name>
Show full path of a command, useful for checking if a program is installed, or if it's in the search path in $PATH environment variable:
> which <cmd name>
View documentation of a command. [q] to exit. [h] for help:
> man <cmd name>
Search man pages:
> apropos <string>
Find a file by name (using the database see man updatedb). This is similar to find <many dir paths> -name "*<search string>*" but much faster:
> locate <search string>
Update the database used by locate:
> updatedb

 * Archive, Compression {tar, gzip} *
Archive a folder:
> tar cvf <new name.tar> <dirpath>
Unarchive:
> tar xvf <filename.tar>
To compress a file:
> gzip <filename>
Decompress a file:
> gzip -d <filename>

 * Managing Process *
View running processes:
> ps -ef
Find a particular process:
> ps -ef | grep <name>
Quit a program that has process id <pid>:
> kill <pid>
Force quit a process:
> kill -s 9 <pid>
Monitor processes with continuous update. q to quit:
> top
Show the process parent-child relationship:
> pstree

 * Job Control *
Start a program in background. e.g. emacs &:
> <cmd> &
Stop a command. (sending SIGINT to it) e.g. you did emacs and forgot the &, press [Ctrl+c] to start over:
> [Ctrl+c]
Suspend a command. (sending SIGTSTP to it):
> [Ctrl+z]
Run the suspended command in background:
> bg %<number>
Resume a background process to foreground:
> fg %<number>
Seperate a job process id 1 from jobs:
> disown %1
List background processes:
> jobs

* Sys Admin *
Create a new user account. (On Debian based linuxes, there's higher-level “adduser” written in perl.):
> useradd <user name>
Change password for user:
> passwd <user name>
Show the id number of a user, and all groups he belongs to:
> id <user name>
List all users:
> cat /ect/passwd
List all groups. See getent --help:
> getent group

Change the perm bits. (664 = rw-rw-r--; typical text file perm bits):
> chmod 664 <filename>
Change owner of a file:
> chown <user name> <filename>
Change the group of a file:
> chgrp <group name> <filename>
Make a symbolic link of a file. (symbolic is file that contains the path of another file.):
> ln -s <new name> <filename>
Create hard link of a file. (Hard link makes 2 files pointing to the same index in the file system (hard disk).):
> ln <new name> <filename>
Restart machine now. (power off is -P):
> shutdown -r 0

Show current date and time:
> date
Show time stamp in this format: “yyyy-mm-dd hh:mm:ss-07:00” the last are time offset to UTC:
> date --rfc-3339=seconds
Show who is logged in:
> w
List all users that have logged in recently:
> who -a
Show how long the system's been running:
> uptime
Count the number of chars, words, lines. useful with cat, grep:
> wc

Execute a shell file <shell file>. source <shell file> is equivalent to . <shell file>:
> source <shell file>
Start a new bash. [Ctrl+d] to exit when done:
> bash
View value of a environment variable:
> echo $PATH
Show all environment variables:
> env
Make <str> as shortcut for <cmd>. e.g. alias l="ls -al --color":
> alias <str>="<cmd>";

 * Generic Useful Bash Syntax *
A asterisk “*” means any character. *.txt means all files ending in “.txt”. Can be used for any command that takes list of files or dir. See man 7 glob:
> <cmd> *.txt
Pass the output of <cmd1> to the input of <cmd2>:
> <cmd1> | <cmd2>
Feed the content of <filename> to the input of <cmd>:
> cat <filename> | <cmd>
Write the output to fill:
> <cmd> > <filename>
Append output to fill:
> <cmd> >> <filename>
Join contents of <filename1> <filename2> to <new filename:
> cat <filename1> <filename2> > <new filename>
Run several commands:
> <cmd1>; <cmd2>; …
Run <cmd1>, if success, then run <cmd2> (otherwise stop.) (the && is a logical “and” operator. Unix commands returns 0 if success, else a integer error code:
> <cmd1> && <cmd2>
Fenerate the output of <cmd> and use it in your whole command. e.g. ls -l `which more:
> … `<cmd>` …
Run a command in background:
> … &
