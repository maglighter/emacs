* SVN
command line for server manager.
svn://10.41.1.90:443/DBSync.Multi/GUI/DBSyncGUI2/DbSync2
TestTools
svn://svn2.wisdomforce.net:8080/TestTools
mbubnov
He36FGj

* Shares
\\KZW171169S\setups
\\10.51.40.82\Builds
\\KZW171144\OraDocs
\\10.51.4.152\pub\bigblackbug
ftp://10.51.40.82 share 1q2w3e4r

* Autotests
maximb
maximb

* Oracle
MBUBNOV
bbnv

Alternative for DDL's:
10.51.40.26
user: src / dest
passw: test
instance: orcl

* DB2
db2admin  
bbnV
DB: SOURCE/TARGET

* MSSQL
sa
INfa1234
For autotest:
DB:
ms sql server
host:
10.51.40.114
port:
1433
user:
sa
passw:
sas

* Greenplum
targDB:
autotest
host:
10.51.40.112
port:
5432
user:
gpadmin
passw:
gpadmin

* Email
infaMB@2012
mbubnov@informatica.com

* SUN
  infa348767
** Stop SM
  $ lsof server_manager
  $ kill ...
* HPUX
  
  source ../run
  ./server_manager RUN_AS_SERVICE port=18004 udp_port=18005 dbsync_home=`pwd`
** Stop SM
  $ lsof server_manager
  $ kill ...
** Add NETEZZA driver
   в LD_LIBRARY_PATH добавить /opt/netezza/lib64/ 16:27 
   в odbcinst.ini  16:27 
   прописать  16:27 
   полный путь до драйвера  16:28 
   /opt/netezza/lib64/libnzodbc.sl 

* AIX
  source ../run
  ./server_manager.sh port=18004 udp_port=18005 dbsync_home=`pwd`
** Stop SM:
  $ netstat -Ana|grep LISTEN|grep 18004
     f1000e000590f3b8 tcp4 ...
  $ rmsock f1000e000590f3b8 tcpcb
     The socket 0xf1000e000590f008 is being held by proccess 7405806
  $ kill 7405806
  
* Linux
C:\OraDocs\linux_builds
Линуксовые билды старых версий (хф3 и 9.5.0 напомни попозже докопировать)
Там же putty – для коннекта по ссх, winscp – удобно копировать файлы, dbsync.key – на всякий случай, если СМ будет жаловаться что срок действия лицензии закончился то тоже нужно будет копировать каждый раз для очередной версии.
Распаковываю я обычно сначалаg unzip имя архива, потом tar –xvf имя архива.
Затем перехожу в распакованную папку и прогоняю настройку энвайремента и запуск СМ

export DBSYNC_HOME=`pwd` 
export LD_LIBRARY_PATH=`pwd`/support:$LD_LIBRARY_PATH
export DD_INSTALLDIR=`pwd`/dd 
export LD_LIBRARY_PATH=`pwd`/dd/lib:$LD_LIBRARY_PATH
export ODBCINST=$DBSYNC_HOME/dd/odbcinst.ini
./server_manager.sh port=18004 udp_port=18005 dbsync_home=`pwd`

СМ лучше запускать с прописанным портом , т.к. там могут быть запущены СМ от других тестировщиков и девелоперов (диапазон портов уже распределяли, можешь юзать мой, от 18000 до 18010)
СМ обычно прибиваем через kill номер процесса
Процессы я смотрю через ps –ef|grep server_manager

Линукс для работы: 10.51.40.26, oracle/84218421
Оракл на этом линуксе: dbsync_user/dbsync_user, sid=orcl

* SQL
** DB2
create schema:
call DB2ADMIN.CREATE_SCHEMA('D2G_DDL2_SRC_2924_');
call DB2ADMIN.DROP_TABLE_IF_EXISTS('D2G_DDL2_SRC_2924_','D2G_2924_ADD_COL');

create table D2G_DDL2_SRC_2924_.D2G_2924_ADD_COL (int1 integer not null,PRIMARY KEY (int1));


create table SRC.cnfl_res_1_1(int1 integer not null primary key, fm varchar(20), im varchar(20), otch varchar(20));

CONNECT TO TARGET;
GRANT  CREATEIN,DROPIN,ALTERIN ON SCHEMA TARG TO USER DB2ADMIN WITH GRANT OPTION;
CONNECT RESET;

** Oracle
// If problems with oracle listener, try:
sqlplus / as sysdba
lsnrctl start
lsnrctl
connect as / sysdba

startup
shutdown immediate

startup mount
select log_mode from v$database;
// if ARCHIVELOG:
alter database noarchivelog;
alter database open;

// Connection to oracle autotest database
connect dbsync_user/dbsync_user@(DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=10.51.40.114)(PORT=1521))(CONNECT_DATA=(SERVICE_NAME=orcl)))

ORA_TARGET = MBUBNOV
INSTANCE=orcl
D:\app\mbubnov\fast_recovery_area

// Oracle example:
CREATE TABLE "MBUBNOV"."EXMPL1"
(IDKEY NUMBER(10,0) NOT NULL/*MS SQL Server datatype: INT(10, 0)*/,
DATA VARCHAR2(20 BYTE)/*MS SQL Server datatype: VARCHAR(0, 0)*/,
PRIMARY KEY (IDKEY)
);

// Oracle grant add column (target)
GRANT ALTER ANY TABLE TO // MSSQL add column
ALTER TABLE [dbo].[TABLE_NAME=exmpl.dbo.EXMPL1] ADD [COLUMN_NAME] TYPE;

// delete column
ALTER TABLE tblName DROP COLUMN columnName

// delete all rows from table
TRUNCATE TABLE TABLE_NAME 



















    SELECT - extracts data from a database
    UPDATE - updates data in a database
    DELETE - deletes data from a database
    INSERT INTO - inserts new data into a database

    CREATE DATABASE - creates a new database
    ALTER DATABASE - modifies a database
    CREATE TABLE - creates a new table
    ALTER TABLE - modifies a table
    DROP TABLE - deletes a table
    CREATE INDEX - creates an index (search key)
    DROP INDEX - deletes an index

// show only unical values
SELECT DISTINCT column_name(s)
FROM table_name

// sort by
SELECT column_name(s)
FROM table_name
ORDER BY column_name(s) ASC|DESC

// insertion
INSERT INTO table_name [(column1, column2, column3,...)]
VALUES (value1, value2, value3,...)

// update
UPDATE table_name
SET column1=value, column2=value2,...
WHERE some_column=some_value

// delete
DELETE FROM table_name
WHERE some_column=some_value

SELECT TOP number|percent column_name(s)
FROM table_name

MySQL Syntax:
SELECT column_name(s)
FROM table_name
LIMIT number

Oracle Syntax:
SELECT column_name(s)
FROM table_name
WHERE ROWNUM <= number

// regexp (wildcards); % - *; '%end_symbols', 'begin_symbols%', 'middle_symbols%'
% 	  	A substitute for zero or more characters
_		A substitute for exactly one character
[charlist] 	Any single character in charlist
[^charlist] 	Any single character not in charlist
[!charlist]

SELECT column_name(s)
FROM table_name
WHERE column_name LIKE pattern

// listing 1,2,3...
SELECT column_name(s)
FROM table_name
WHERE column_name IN (value1,value2,...)

// range 1..3
SELECT column_name(s)
FROM table_name
BETWEEN value1 AND value2

// Alias Syntax for Tables
SELECT column_name(s)
FROM table_name
AS alias_name
// Alias Syntax for Columns
SELECT column_name AS alias_name
FROM table_name

Exmpl:
SELECT po.OrderID, p.LastName, p.FirstName
FROM Persons AS p, Product_Orders AS po
WHERE p.LastName='Hansen' AND p.FirstName='Ola' 

// JOIN = INNER JOIN; LEFT JOIN; RIGHT JOIN; FULL JOIN;
SELECT column_name(s)
FROM table_name1
INNER JOIN table_name2
ON table_name1.column_name=table_name2.column_name

// UNION - only distincts, UNION ALL - all values
SELECT column_name(s) FROM table_name1
UNION
SELECT column_name(s) FROM table_name2

// Insertion columns in table
SELECT column_name(s)
INTO new_table_name [IN externaldatabase]
FROM old_tablename

// Create databse
CREATE DATABASE database_name

// Create table
CREATE TABLE table_name
(
column_name1 data_type,
column_name2 data_type,
column_name3 data_type,
....
)

SQL Constraints:
    NOT NULL - enforces a column to NOT accept NULL values.
    UNIQUE - uniquely identifies each record in a database table
    	     Ex: P_Id int NOT NULL UNIQUE or CONSTRAINT uc_PersonID UNIQUE
	     (P_Id,LastName)
    PRIMARY KEY
    FOREIGN KEY - points to a PRIMARY KEY in another table
    CHECK - used to limit the value range that can be placed in a column
    	    Ex: CHECK (P_Id>0)
    DEFAULT - used to insert a default value into a column, if no other value is	    specified

// Creates an index on a table. Duplicate values are allowed:
CREATE INDEX index_name
ON table_name (column_name)
// Duplicate values not allowed
CREATE UNIQUE INDEX index_name
ON table_name (column_name)
// Delete indexes
DROP INDEX index_name ON table_name
// Delete table
DROP TABLE table_name
// Delete database
DROP DATABASE database_name
// Delete data in the table
TRUNCATE TABLE table_name

// Modify table
ALTER TABLE table_name
ADD column_name datatype



DevTrack example
INFA338673 	Unable to apply a DDL column change for column [S_CLOB]

http://10.51.40.27:7777/pls/udrtr/f?p=101:5:0::NO:5:P5_RC_ID:21850
1. Create configuration with DDL capturing
2. Map tables
3. Drop columns and replicate (ALTER TABLE O2D_DDL_2.O2D_DDL_2_RAWLOBTYPES DROP (S_RAW_MAX, S_RAW_MIN, S_CLOB);)
4. Add data and replicate
3. Add columns:
ALTER TABLE O2D_DDL_2.O2D_DDL_2_RAWLOBTYPES ADD (
    S_RAW_MAX RAW(2000),
    S_RAW_MIN RAW(1),
    S_CLOB CLOB);
4. Insert data and replicate (INSERT INTO O2D_DDL_2.O2D_DDL_2_RAWLOBTYPES (S_RAW_MAX,  S_RAW_MID, S_RAW_MIN, S_BLOB, S_CLOB, S_PK_FORMAPPING) VALUES (hextoraw('23bc'), hextoraw('af32'), hextoraw('2A'), hextoraw('453d7a34'), hextoraw('633e7a32'), 4)
5. Get Applier error:
[Tue Mar 26 2013 17:14:14.451] Unable to apply a DDL column change for column [S_CLOB]
SQL: ALTER TABLE "O2D_DDL_2"."O2D_DDL_2_RAWLOBTYPES" ADD COLUMN "S_CLOB" CLOB(0)
MSG: -604 [IBM][CLI Driver][DB2/NT] SQL0604N  The length, precision, or scale attribute for column, distinct type, structured type, array type, attribute of structured type, routine, cast target type, type mapping, or global variable "S_CLOB" is not valid.  SQLSTATE=42611



1. create configuration with DDL capturing
2. map tables
3. change source datatypes, and replicate it:
ALTER TABLE O2O_DDL_5.O2O_DDL_5_NUMBERTYPES MODIFY S_NUMBER_MAX INTEGER; (was NUMBER(38,10);)
...
4. insert data in source, replicate
5. get Applier error:
6. [Tue Apr 23 2013 17:45:27.375] Fatal otl_exception in MyOtlStream::flush(int,bool) (51932)
[Tue Apr 23 2013 17:45:27.376] Fatal otl_exception in OTLApplierHelper::FlushAllStreams (51932)
[Tue Apr 23 2013 17:45:27.376] Sql: INSERT INTO "O2O_DDL_5_T"."O2O_DDL_5_NUMBERTYPES"("S_NUMBER_MAX","S_NUMBER_MID","S_NUMBER_MIN","S_INTEGER","S_BINARY_DOUBLE","S_BINARY_FLOAT","S_DECIMAL_MAX","S_DECIMAL_MID","S_DECIMAL_MIN","S_DOUBLE_PRECISION_FLOAT_MAX","S_DOUBLE_PRECISION_FLOAT_MID","S_DOUBLE_PRECISION_FLOAT_MIN","S_PK_FORMAPPING") VALUES (:P1,:P2,:P3,:P4,:P5,:P6,:P7,:P8,:P9,:P10,:P11,:P12,:P13) 
[Tue Apr 23 2013 17:45:27.376] Msg: 1722 ORA-01722: invalid number
[Tue Apr 23 2013 17:45:27.385] Fatal otl_exception in ParallelPostRecordTask::svc (51932)
[Tue Apr 23 2013 17:45:27.385] Msg: -99 ParallelPostRecordTask::FlushAllStreams Failed
[Tue Apr 23 2013 17:45:27.394] Apply thread 0 aborted with error code 2
[Tue Apr 23 2013 17:45:27.394] Apply cycle aborted due to fatal errors, correct the specified problems and run the apply cycle again.
[Tue Apr 23 2013 17:45:27.408] Error during finalization of PostTaskExecutor.

* Supported DDLs
Failed: m2v_4, m2v_5, o2v_1, s2v_3, s2v_5, s2td_2, s2t_5.
** Sources
*** DB2
  ALTER TABLE table_name ADD column_name datatype [NULL|NOT NULL]
  ALTER TABLE table_name ADD CONSTRAINT constraint_name {PRIMARY KEY|UNIQUE} (column_name)
  ALTER TABLE table_name ALTER COLUMN column_name SET DATA TYPE datatype
  ALTER TABLE table_name ALTER COLUMN column_name SET NOT NULL
?  ALTER TABLE table_name ALTER column_name DROP NOT NULL
  ALTER TABLE table_name DROP column_name
  ALTER TABLE table_name DROP CONSTRAINT constraint_name
  CREATE [UNIQUE] INDEX index_name ON table_name
  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL] [PRIMARY KEY] [UNIQUE])
  CREATE TABLE table_name AS (SELECT statement)
-  CREATE TABLE table_name LIKE table_name
  DROP INDEX index_name
  DROP TABLE table_name
  TRUNCATE TABLE table_name
  
  Notes:
  The Applier processes the CREATE INDEX statement only if this statement creates an index in the same schema
as the parent table.
  When a CREATE TABLE AS (SELECT...) operation occurs on the source, Data Replication creates a target table
using the appropriate CREATE TABLE statement. After you execute REFRESH statements for the source table,
Data Replication begins applying DML operations to the target table

*** MSSQL
The Extractor for Microsoft SQL Server sources can process the following DDL operations:
  ALTER TABLE table_name ADD column_name datatype [IDENTITY] [NULL|NOT NULL] [UNIQUE]
  ALTER TABLE table_name ADD CONSTRAINT constraint_name PRIMARY KEY {CLUSTERED|NONCLUSTERED}
  ALTER TABLE table_name ALTER COLUMN column_name datatype [NULL|NOT NULL]
  ALTER TABLE table_name DROP COLUMN column_name
  ALTER TABLE table_name DROP CONSTRAINT constraint_name
  CREATE [UNIQUE] [CLUSTERED] INDEX index_name ON table_name (column_name)
  CREATE TABLE table_name (column_name datatype [IDENTITY] [NULL|NOT NULL] [UNIQUE])
  DROP INDEX index_name ON table_name
  DROP TABLE table_name
  SELECT * INTO new_table_name FROM existing_table_name

Notes:
  Data Replication incorrectly replicates a SELECT * INTO operation if the source columns have LOB datatypes
such as IMAGE, NTEXT, NVARCHAR(MAX), TEXT, VARBINARY(MAX), and VARCHAR(MAX).
  Data Replication can replicate DDL operations that include identity columns. When replicating these DDL
operations to Oracle targets, which do not use identity columns, Data Replication replaces identity columns with
standard table columns.
  Data Replication does not support the replication of TRUNCATE TABLE operations from Microsoft SQL Server
sources.
  After a CREATE TABLE operation occurs on the source, you must manually enable Replicate mode for this table to
replicate change data to the target.

*** Oracle
The Extractor for Oracle sources can process the following DDL operations:
  ALTER TABLE table_name ADD (column_name datatype [CONSTRAINT constraint_name {NOT NULL|UNIQUE}]
  [ENCRYPT|ENCRYPT USING|DECRYPT] [SALT|NO SALT])
  ALTER TABLE table_name ADD CONSTRAINT constraint_name
  ALTER TABLE table_name DROP (column_name)
  ALTER TABLE table_name DROP CONSTRAINT constraint_name
  ALTER TABLE table_name DROP {UNIQUE (column_name)|PRIMARY KEY}
  ALTER TABLE table_name MODIFY (column_name datatype [ENCRYPT|ENCRYPT USING|DECRYPT] [SALT|NO SALT])
  ALTER TABLE table_name RENAME COLUMN column_name TO new_column_name
  CREATE INDEX index_name ON table_name
  CREATE TABLE table_name (column_name datatype [CONSTRAINT constraint_name {NOT NULL|UNIQUE}]
[ENCRYPT|ENCRYPT USING|DECRYPT] [SALT|NO SALT])
  CREATE TABLE table_name AS SELECT statement
  DROP INDEX index_name
  DROP TABLE table_name
  TRUNCATE TABLE table_name

Notes:
  For replication configurations with Oracle source and Oracle targets, Data Replication replicates index-organized
tables to identical index-organized target tables. If you have a target type other than Oracle, Data Replication
replicates index-organized tables to ordinary target tables.
  If you replicate a CREATE TABLE operation that creates an index-organized table on the source and the primary
key column is not the first column in this table, the Applier creates the table on the target with the primary key as the
first column. Consequently, the Applier cannot replicate change data to this target table.
  Data Replication does not support replication of CREATE TABLE ... AS SELECT statements that create an indexorganized
table.
  If you replicate a CREATE TABLE operation that creates a table with a column that has LONG datatype on the
source, the Applier changes the column order in the corresponding target table. The Applier swaps the LONG
column with the last table column on the target. If the source table defines a primary key that includes the last table
column, the Applier creates a primary key that includes the LONG column instead of the last column for the target
table.
  Data Replication can replicate CREATE TABLE AS SELECT * FROM operations if the replicated table does not
contain LOB data.
  Data Replication does not support the replication of function-based indexes.
  Data Replication does not support the replication of function-based default values.
  Data Replication does not support the replication of indexes that are associated with a constraint. Data Replication
replicates constraints without the associated index.
  Data Replication does not support the replication of the ENCRYPT keyword for Oracle source columns. On the
target, Data Replication creates corresponding columns without the ENCRYPT keyword.
  Data Replication does not replicate temporary tables.

*** SYBASE ASE
The Extractor for Sybase ASE sources can process the following DDL operations:
  ALTER TABLE table_name ADD column_name datatype [NULL]
  ALTER TABLE table_name DROP column_name
  ALTER TABLE table_name MODIFY column_name [NULL|NOT NULL]
  CREATE NONCLUSTERED INDEX index_name ON table_name (column_name)    
  CREATE TABLE table_name (column_name datatype [NULL] [PRIMARY KEY])
  DROP INDEX index_name
  DROP TABLE table_name
  TRUNCATE TABLE table_name

Notes:
  Data Replication does not replicate ALTER TABLE operations that set the NULL option for columns that have the
NOT NULL constraint. Data Replication does not replicate these DDL operations for Sybase columns with the
following datatypes: char, varchar, nchar, nvarchar, unichar, univarchar, binary, varbinary, text, image, and
unitext.
  Data Replication does not replicate ALTER TABLE operations that change column length without changing the
column datatype.
  When a CREATE TABLE AS SELECT operation occurs on the source, Data Replication creates an empty target
table using an appropriate CREATE TABLE statement. Data Replication does not copy data from the parent table
to the target table.
  If you execute multiple CREATE TABLE, ALTER TABLE, and DROP TABLE statements at the same time by using
a script or Interactive SQL, you must end each statement with the go command. Otherwise, the Extractor cannot
correctly process these statements.
  Data Replication can replicate DDL operations that include identity columns. When replicating these DDL
operations to Oracle targets that do not use identity columns, Data Replication replaces identity columns with
standard table columns.

** d2X
*** DB2
The Applier task can apply the following DDL operations to DB2 for Linux, UNIX, and Windows targets:
2  ALTER TABLE table_name ADD column datatype [NULL|NOT NULL]
5  ALTER TABLE table_name ADD CONSTRAINT constraint_name {PRIMARY KEY|UNIQUE} (column_name)
a7  ALTER TABLE table_name ALTER COLUMN column_name SET DATA TYPE datatype
a7  ALTER TABLE table_name ALTER COLUMN column_name SET NOT NULL
a7  ALTER TABLE table_name ALTER column_name DROP NOT NULL
2  ALTER TABLE table_name DROP column_name
5  ALTER TABLE table_name DROP CONSTRAINT constraint_name
n  ALTER TABLE table_name RENAME COLUMN column_name TO new_column_name
a7  CREATE [UNIQUE] INDEX index_name ON table_name
1  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL] [PRIMARY KEY] [UNIQUE])
a7  DROP INDEX index_name
a7  DROP TABLE table_name
5  TRUNCATE TABLE table_name

Notes:
  The Applier processes the CREATE INDEX statement only if this statement creates an index in the same schema
as the parent table.

*** Greenplum
The Applier task can apply the following DDL operations to Greenplum targets:
2  ALTER TABLE table_name ADD column_name datatype [NULL]
3  ALTER TABLE table_name ADD CONSTRAINT constraint_name PRIMARY KEY (column_name)
3  ALTER TABLE table_name ALTER COLUMN column_name SET NOT NULL
5  ALTER TABLE table_name ALTER COLUMN column_name TYPE datatype
2  ALTER TABLE table_name DROP COLUMN column_name CASCADE
3  ALTER TABLE table_name DROP CONSTRAINT constraint_name CASCADE
3  CREATE INDEX index_name ON table_name (column_name)
1  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL]) DISTRIBUTED RANDOMLY
3  DROP INDEX index_name CASCADE
1  DROP TABLE table_name
4  TRUNCATE TABLE table_name

e3 create table table_name as (select S_CHAR, count(*) as c_quantity from tablename S_CHAR )


Notes:
  For Oracle sources, Data Replication, by default, cannot replicate DROP CONSTRAINT operations that drop a
primary key. When extracting these DDL operations, the Extractor sets the NULL option on the primary key
columns. However, Greenplum does not support altering primary key columns. If you execute DROP
CONSTRAINT operations that drop a primary key on the source, set the apply.skip_alter_column_failed_ddl
runtime parameter to 0. This setting causes the Applier to not set the NULL option for the primary key columns on
the target. You can then set the NULL option for these columns manually.
  To replicate CREATE TABLE and ADD COLUMN operations to Greenplum targets in Audit Apply and Merge Apply
modes, you must specify table and column names in all lowercase on the source. If you use uppercase, the Applier
cannot replicate subsequent DML operations for the new table or column.    

*** MSSQL
The Applier task can apply the following DDL operations to Microsoft SQL Server targets:
2  ALTER TABLE table_name ADD column_name datatype [IDENTITY] [NULL|NOT NULL] [UNIQUE]
3  ALTER TABLE table_name ADD CONSTRAINT constraint_name PRIMARY KEY {CLUSTERED|NONCLUSTERED}
3  ALTER TABLE table_name ALTER COLUMN column_name datatype [NULL|NOT NULL]
2  ALTER TABLE table_name DROP COLUMN column_name
3  ALTER TABLE table_name DROP CONSTRAINT constraint_name
3  CREATE [UNIQUE] [CLUSTERED] INDEX index_name ON table_name (column_name)
1  CREATE TABLE table_name (column_name datatype [IDENTITY] [NULL|NOT NULL] [UNIQUE])
a6  DROP INDEX index_name ON table_name
1  DROP TABLE table_name
4  SELECT * INTO new_table_name FROM existing_table_name
4  TRUNCATE TABLE table_name

Note:
Data Replication replicates RENAME COLUMN operations from Oracle sources to Microsoft SQL Server
targets as the following operation:
EXEC sp_rename 'table_name.[old_column_name]', 'new_column_name', 'COLUMN'

*** MySQL
The Applier task can apply the following DDL operations to MySQL targets:
2  ALTER TABLE table_name ADD column_name datatype [NULL|NOT NULL]
3  ALTER TABLE table_name ADD CONSTRAINT constraint_name PRIMARY KEY (column_name)
n   ALTER TABLE table_name CHANGE old_column_name new_column_name datatype [NULL|NOT NULL]
2  ALTER TABLE table_name DROP COLUMN column_name
3  ALTER TABLE table_name DROP PRIMARY KEY
3  ALTER TABLE table_name MODIFY column_name datatype [NULL|NOT NULL]
3  CREATE [UNIQUE] INDEX index_name ON table_name (column_name);
1  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL] [PRIMARY KEY (column_name)])
3  DROP INDEX index_name ON table_name
1  DROP TABLE table_name

4  SELECT * INTO new_table_name FROM existing_table_name

Note:
Data Replication replicates TRUNCATE operations from sources to MySQL targets as DELETE FROM
operations.

*** Netezza
The Applier task can apply the following DDL operations to Netezza targets:
2  ALTER TABLE table_name ADD column_name datatype [NULL|NOT NULL]
3  ALTER TABLE table_name ADD CONSTRAINT constraint_name UNIQUE (column_name)
2  ALTER TABLE table_name DROP COLUMN column_name CASCADE
3  ALTER TABLE table_name DROP CONSTRAINT constraint_name CASCADE
5  ALTER TABLE table_name MODIFY COLUMN column_name datatype
1  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL] [PRIMARY KEY (column_name)]) DISTRIBUTE ON {(column_name)|RANDOM}
1  DROP TABLE table_name

4  Create as select

Notes:
  Data Replication does not replicate indexes that were created on a source database to Netezza targets because
Netezza does not use indexes.
  Data Replication does not replicate ALTER COLUMN operations that add NULL and NOT NULL constraints to a
source column to Netezza targets because Netezza does not support these types of DDL operations.
  Data Replication does not replicate ALTER COLUMN operations that modify a column datatype to Netezza targets
because Netezza does not support these types of DDL operations.
  Data Replication does not replicate ALTER COLUMN operations that modify the length of columns that have a
datatype other than VARCHAR to Netezza targets because Netezza does not support these types of DDL
operations.
  Data Replication does not replicate ADD COLUMN operations that add a column that has a NOT NULL constraint
but no default value from Oracle sources to Netezza targets. Netezza does not support these types of DDL
operations.
  Data Replication replicates TRUNCATE operations from sources to Netezza targets as DELETE FROM
operations.
  To replicate CREATE TABLE operation to Netezza targets, Data Replication creates a table on the target and
distributes data on the columns that are mapped to the primary key columns on the source. If the source table does
not have a primary key definition, Data Replication uses the DISTRIBUTE ON RANDOM clause.    

*** Oracle
The Applier task can apply the following DDL operations to Oracle targets:
2  ALTER TABLE table_name ADD (column_name datatype [CONSTRAINT constraint_name {NOT NULL|UNIQUE}]
3  ALTER TABLE table_name ADD CONSTRAINT constraint_name
2  ALTER TABLE table_name DROP (column_name)
3  ALTER TABLE table_name DROP CONSTRAINT constraint_name
3  ALTER TABLE table_name DROP {UNIQUE (column_name)|PRIMARY KEY}
5  ALTER TABLE table_name MODIFY (column_name datatype
n  ALTER TABLE table_name RENAME COLUMN column_name TO new_column_name
3  CREATE INDEX index_name ON table_name
1  CREATE TABLE table_name (column_name datatype [CONSTRAINT constraint_name {NOT NULL|UNIQUE}]
4  CREATE TABLE table_name AS SELECT statement
3  DROP INDEX index_name
1  DROP TABLE table_name
4  TRUNCATE TABLE table_name

Notes:
  When replicating DDL changes from Microsoft SQL Server sources to Oracle targets, Data Replication does not
replicate ALTER COLUMN operations that change a column datatype from VARCHAR(n) to VARCHAR(MAX).
Data Replication maps the SQL Server VARCHAR(MAX) datatype to the Oracle CLOB datatype, but Oracle does
not support an ALTER COLUMN operation that changes a VARCHAR column to a CLOB column.
  To replicate CREATE TABLE and ADD COLUMN operations to Oracle targets in Audit Apply and Merge Apply
modes, you must specify table and column names in all uppercase on the source. If you use lowercase, the Applier
cannot replicate subsequent DML operations for the new table or column.    

*** PostgreSQL
The Applier task can apply the following DDL operations to PostgreSQL targets:
2  ALTER TABLE table_name ADD column_name datatype
3  ALTER TABLE table_name ADD CONSTRAINT constraint_name [PRIMARY KEY|UNIQUE] (column_name)
5  ALTER TABLE table_name ALTER COLUMN column_name SET DATA TYPE datatype
3  ALTER TABLE table_name ALTER COLUMN column_name SET NOT NULL
2  ALTER TABLE table_name DROP COLUMN column_name CASCADE
3  ALTER TABLE table_name DROP CONSTRAINT constraint_name CASCADE
3  CREATE INDEX index_name ON table_name (column_name)
1  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL] [PRIMARY KEY (column_name))
3  DROP INDEX index_name CASCADE
1  DROP TABLE table_name
  TRUNCATE table_name

4 create as select


Note:
Data Replication does not enclose table names in quotes when replicating the TRUNCATE TABLE
operations. Consequently, the Applier ends abnormally when replicating the TRUNCATE TABLE statements for
the target tables that have case-sensitive names.    

*** SybaseASE
The Applier task can apply the following DDL operations to Sybase ASE targets:
2  ALTER TABLE table_name ADD column_name datatype [NULL|NOT NULL]
2  ALTER TABLE table_name DROP column_name
5  ALTER TABLE table_name MODIFY column_name datatype [NULL|NOT NULL]
3  CREATE INDEX index_name ON table_name (column_name)
1  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL]) LOCK DATAROWS
3  DROP INDEX table_name.index_name
1  DROP TABLE table_name
4  TRUNCATE TABLE table_name

3  Add primary key
3  Drop primary key
4  create as select

Note:
Data Replication does not replicate DDL operations that add a nullable BIT column from Microsoft SQL Server
sources to Sybase ASE targets because Sybase ASE does not support nullable BIT columns.    

*** Teradata
The Applier task can apply the following DDL operations to Teradata targets:
2  ALTER TABLE table_name ADD column_name datatype [NULL|NOT NULL]
3  ALTER TABLE table_name ADD CONSTRAINT constraint_name UNIQUE (column_name)
3  ALTER TABLE table_name DROP CONSTRAINT constraint_name
1  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL]) PRIMARY INDEX (column_name)
3  CREATE UNIQUE INDEX index_name (column_name) ON table_name
3  DROP INDEX index_name ON table_name
1  DROP TABLE table_name

3 set not null
4 create as select
5 alter table set datatype

Notes:
  Data Replication does not replicate ALTER TABLE operations that modify a source column datatype to Teradata
targets because Teradata does not support these types of DDL operations.
  Data Replication does not replicate DROP COLUMN operations for the source columns that are part of the primary
key. For source tables that do not have a primary key, Data Replication does not replicate DROP COLUMN
operations for the first column.
  Data Replication replicates TRUNCATE operations from sources to Teradata targets as DELETE ALL
operations.    

*** Vertica
The Applier task can apply the following DDL operations to Vertica targets:
3  ALTER TABLE table_name ADD CONSTRAINT constraint_name {UNIQUE|PRIMARY KEY} (column_name)
3  ALTER TABLE table_name DROP CONSTRAINT constraint_name CASCADE
2  ALTER TABLE table_name ADD column_name datatype
2  ALTER TABLE table_name DROP COLUMN column_name CASCADE
  ALTER TABLE table_name ALTER COLUMN column_name SET DEFAULT default_value
  ALTER TABLE table_name ALTER COLUMN column_name SET NOT NULL
5  ALTER TABLE table_name ALTER COLUMN column_name SET DATA TYPE datatype
n  ALTER TABLE table_name RENAME COLUMN column_name TO new_column_name
1  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL] [PRIMARY KEY (column_name)])
[SEGMENTED BY HASH (column_name) ALL NODES]
1  DROP TABLE table_name
4  TRUNCATE TABLE table_name

3 create index
3 drop index


Notes:
  The Applier ends abnormally when applying a source ADD column_name operation that has the NULL, NOT
NULL, or DEFAULT clause.
  Data Replication replicates ALTER COLUMN operations that change column datatypes only for target BINARY,
VARBINARY, CHAR, and VARCHAR columns that have no default values.    

** m2X
*** DB2
The Applier task can apply the following DDL operations to DB2 for Linux, UNIX, and Windows targets:
2  ALTER TABLE table_name ADD column datatype [NULL|NOT NULL]
  ALTER TABLE table_name ADD CONSTRAINT constraint_name {PRIMARY KEY|UNIQUE} (column_name)
5  ALTER TABLE table_name ALTER COLUMN column_name SET DATA TYPE datatype
n  ALTER TABLE table_name ALTER COLUMN column_name SET NOT NULL
n  ALTER TABLE table_name ALTER column_name DROP NOT NULL
2  ALTER TABLE table_name DROP column_name
  ALTER TABLE table_name DROP CONSTRAINT constraint_name
n  ALTER TABLE table_name RENAME COLUMN column_name TO new_column_name
3  CREATE [UNIQUE] INDEX index_name ON table_name
1  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL] [PRIMARY KEY] [UNIQUE])
3  DROP INDEX index_name
1  DROP TABLE table_name
n  TRUNCATE TABLE table_name

4  create as select 

Notes:
  The Applier processes the CREATE INDEX statement only if this statement creates an index in the same schema
as the parent table.

*** Greenplum
The Applier task can apply the following DDL operations to Greenplum targets:
2  ALTER TABLE table_name ADD column_name datatype [NULL]
  ALTER TABLE table_name ADD CONSTRAINT constraint_name PRIMARY KEY (column_name)
n  ALTER TABLE table_name ALTER COLUMN column_name SET NOT NULL
5  ALTER TABLE table_name ALTER COLUMN column_name TYPE datatype
2  ALTER TABLE table_name DROP COLUMN column_name CASCADE
  ALTER TABLE table_name DROP CONSTRAINT constraint_name CASCADE
3  CREATE INDEX index_name ON table_name (column_name)
1  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL]) DISTRIBUTED RANDOMLY
3  DROP INDEX index_name CASCADE
1  DROP TABLE table_name
n  TRUNCATE TABLE table_name

4  create table as select


Notes:
  For Oracle sources, Data Replication, by default, cannot replicate DROP CONSTRAINT operations that drop a
primary key. When extracting these DDL operations, the Extractor sets the NULL option on the primary key
columns. However, Greenplum does not support altering primary key columns. If you execute DROP
CONSTRAINT operations that drop a primary key on the source, set the apply.skip_alter_column_failed_ddl
runtime parameter to 0. This setting causes the Applier to not set the NULL option for the primary key columns on
the target. You can then set the NULL option for these columns manually.
  To replicate CREATE TABLE and ADD COLUMN operations to Greenplum targets in Audit Apply and Merge Apply
modes, you must specify table and column names in all lowercase on the source. If you use uppercase, the Applier
cannot replicate subsequent DML operations for the new table or column.    

*** MSSQL
The Applier task can apply the following DDL operations to Microsoft SQL Server targets:
2  ALTER TABLE table_name ADD column_name datatype [IDENTITY] [NULL|NOT NULL] [UNIQUE]
  ALTER TABLE table_name ADD CONSTRAINT constraint_name PRIMARY KEY {CLUSTERED|NONCLUSTERED}
5  ALTER TABLE table_name ALTER COLUMN column_name datatype [NULL|NOT NULL]
2  ALTER TABLE table_name DROP COLUMN column_name
  ALTER TABLE table_name DROP CONSTRAINT constraint_name
3  CREATE [UNIQUE] [CLUSTERED] INDEX index_name ON table_name (column_name)
1  CREATE TABLE table_name (column_name datatype [IDENTITY] [NULL|NOT NULL] [UNIQUE])
3  DROP INDEX index_name ON table_name
1  DROP TABLE table_name
  SELECT * INTO new_table_name FROM existing_table_name
n  TRUNCATE TABLE table_name

4  Create As Select

Note:
Data Replication replicates RENAME COLUMN operations from Oracle sources to Microsoft SQL Server
targets as the following operation:
EXEC sp_rename 'table_name.[old_column_name]', 'new_column_name', 'COLUMN'

*** MySQL
The Applier task can apply the following DDL operations to MySQL targets:
2  ALTER TABLE table_name ADD column_name datatype [NULL|NOT NULL]
  ALTER TABLE table_name ADD CONSTRAINT constraint_name PRIMARY KEY (column_name)
n  ALTER TABLE table_name CHANGE old_column_name new_column_name datatype [NULL|NOT NULL]
2  ALTER TABLE table_name DROP COLUMN column_name
  ALTER TABLE table_name DROP PRIMARY KEY
5  ALTER TABLE table_name MODIFY column_name datatype [NULL|NOT NULL]
3  CREATE [UNIQUE] INDEX index_name ON table_name (column_name);
1  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL] [PRIMARY KEY (column_name)])
3  DROP INDEX index_name ON table_name
1  DROP TABLE table_name

4  SELECT * INTO new_table_name FROM existing_table_name

Note:
Data Replication replicates TRUNCATE operations from sources to MySQL targets as DELETE FROM
operations.

*** Netezza
The Applier task can apply the following DDL operations to Netezza targets:
2  ALTER TABLE table_name ADD column_name datatype [NULL|NOT NULL]
  ALTER TABLE table_name ADD CONSTRAINT constraint_name UNIQUE (column_name)
2  ALTER TABLE table_name DROP COLUMN column_name CASCADE
  ALTER TABLE table_name DROP CONSTRAINT constraint_name CASCADE
5  ALTER TABLE table_name MODIFY COLUMN column_name datatype
1  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL] [PRIMARY KEY (column_name)]) DISTRIBUTE ON {(column_name)|RANDOM}
1  DROP TABLE table_name

4  Create as select

Notes:
  Data Replication does not replicate indexes that were created on a source database to Netezza targets because
Netezza does not use indexes.
  Data Replication does not replicate ALTER COLUMN operations that add NULL and NOT NULL constraints to a
source column to Netezza targets because Netezza does not support these types of DDL operations.
  Data Replication does not replicate ALTER COLUMN operations that modify a column datatype to Netezza targets
because Netezza does not support these types of DDL operations.
  Data Replication does not replicate ALTER COLUMN operations that modify the length of columns that have a
datatype other than VARCHAR to Netezza targets because Netezza does not support these types of DDL
operations.
  Data Replication does not replicate ADD COLUMN operations that add a column that has a NOT NULL constraint
but no default value from Oracle sources to Netezza targets. Netezza does not support these types of DDL
operations.
  Data Replication replicates TRUNCATE operations from sources to Netezza targets as DELETE FROM
operations.
  To replicate CREATE TABLE operation to Netezza targets, Data Replication creates a table on the target and
distributes data on the columns that are mapped to the primary key columns on the source. If the source table does
not have a primary key definition, Data Replication uses the DISTRIBUTE ON RANDOM clause.    

*** Oracle
The Applier task can apply the following DDL operations to Oracle targets:
2  ALTER TABLE table_name ADD (column_name datatype [CONSTRAINT constraint_name {NOT NULL|UNIQUE}]
1  ALTER TABLE table_name ADD CONSTRAINT constraint_name
6  ALTER TABLE table_name DROP (column_name)
1  ALTER TABLE table_name DROP CONSTRAINT constraint_name
1  ALTER TABLE table_name DROP {UNIQUE (column_name)|PRIMARY KEY}
5  ALTER TABLE table_name MODIFY (column_name datatype
n  ALTER TABLE table_name RENAME COLUMN column_name TO new_column_name
3  CREATE INDEX index_name ON table_name
1  CREATE TABLE table_name (column_name datatype [CONSTRAINT constraint_name {NOT NULL|UNIQUE}]
3  CREATE TABLE table_name AS SELECT statement
3  DROP INDEX index_name
1  DROP TABLE table_name
n  TRUNCATE TABLE table_name

Notes:
  When replicating DDL changes from Microsoft SQL Server sources to Oracle targets, Data Replication does not
replicate ALTER COLUMN operations that change a column datatype from VARCHAR(n) to VARCHAR(MAX).
Data Replication maps the SQL Server VARCHAR(MAX) datatype to the Oracle CLOB datatype, but Oracle does
not support an ALTER COLUMN operation that changes a VARCHAR column to a CLOB column.
  To replicate CREATE TABLE and ADD COLUMN operations to Oracle targets in Audit Apply and Merge Apply
modes, you must specify table and column names in all uppercase on the source. If you use lowercase, the Applier
cannot replicate subsequent DML operations for the new table or column.    

*** PostgreSQL
The Applier task can apply the following DDL operations to PostgreSQL targets:
2  ALTER TABLE table_name ADD column_name datatype
  ALTER TABLE table_name ADD CONSTRAINT constraint_name [PRIMARY KEY|UNIQUE] (column_name)
5  ALTER TABLE table_name ALTER COLUMN column_name SET DATA TYPE datatype
n  ALTER TABLE table_name ALTER COLUMN column_name SET NOT NULL
2  ALTER TABLE table_name DROP COLUMN column_name CASCADE
  ALTER TABLE table_name DROP CONSTRAINT constraint_name CASCADE
d3  CREATE INDEX index_name ON table_name (column_name)
1  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL] [PRIMARY KEY (column_name))
d3  DROP INDEX index_name CASCADE
1  DROP TABLE table_name
n  TRUNCATE table_name

4  create as select


Note:
Data Replication does not enclose table names in quotes when replicating the TRUNCATE TABLE
operations. Consequently, the Applier ends abnormally when replicating the TRUNCATE TABLE statements for
the target tables that have case-sensitive names.    

*** SybaseASE
The Applier task can apply the following DDL operations to Sybase ASE targets:
2  ALTER TABLE table_name ADD column_name datatype [NULL|NOT NULL]
6  ALTER TABLE table_name DROP column_name
4  ALTER TABLE table_name MODIFY column_name datatype [NULL|NOT NULL]
3  CREATE INDEX index_name ON table_name (column_name)
1  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL]) LOCK DATAROWS
3  DROP INDEX table_name.index_name
1  DROP TABLE table_name
n  TRUNCATE TABLE table_name

1  Add constraint


Note:
Data Replication does not replicate DDL operations that add a nullable BIT column from Microsoft SQL Server
sources to Sybase ASE targets because Sybase ASE does not support nullable BIT columns.    

*** Teradata
The Applier task can apply the following DDL operations to Teradata targets:
2  ALTER TABLE table_name ADD column_name datatype [NULL|NOT NULL]
  ALTER TABLE table_name ADD CONSTRAINT constraint_name UNIQUE (column_name)
  ALTER TABLE table_name DROP CONSTRAINT constraint_name
1  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL]) PRIMARY INDEX (column_name)
3  CREATE UNIQUE INDEX index_name (column_name) ON table_name
3  DROP INDEX index_name ON table_name
1  DROP TABLE table_name

4 create as select
5 alter table alter column c d null

Notes:
  Data Replication does not replicate ALTER TABLE operations that modify a source column datatype to Teradata
targets because Teradata does not support these types of DDL operations.
  Data Replication does not replicate DROP COLUMN operations for the source columns that are part of the primary
key. For source tables that do not have a primary key, Data Replication does not replicate DROP COLUMN
operations for the first column.
  Data Replication replicates TRUNCATE operations from sources to Teradata targets as DELETE ALL
operations.    

*** Vertica
The Applier task can apply the following DDL operations to Vertica targets:
  ALTER TABLE table_name ADD CONSTRAINT constraint_name {UNIQUE|PRIMARY KEY} (column_name)
  ALTER TABLE table_name DROP CONSTRAINT constraint_name CASCADE
2  ALTER TABLE table_name ADD column_name datatype
2  ALTER TABLE table_name DROP COLUMN column_name CASCADE
n  ALTER TABLE table_name ALTER COLUMN column_name SET DEFAULT default_value
n  ALTER TABLE table_name ALTER COLUMN column_name SET NOT NULL
5  ALTER TABLE table_name ALTER COLUMN column_name SET DATA TYPE datatype
n  ALTER TABLE table_name RENAME COLUMN column_name TO new_column_name
1  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL] [PRIMARY KEY (column_name)])
[SEGMENTED BY HASH (column_name) ALL NODES]
1  DROP TABLE table_name
n  TRUNCATE TABLE table_name

3 create index
3 drop index
4 cas

Notes:
  The Applier ends abnormally when applying a source ADD column_name operation that has the NULL, NOT
NULL, or DEFAULT clause.
  Data Replication replicates ALTER COLUMN operations that change column datatypes only for target BINARY,
VARBINARY, CHAR, and VARCHAR columns that have no default values.
** o2X
*** DB2
The Applier task can apply the following DDL operations to DB2 for Linux, UNIX, and Windows targets:
2  ALTER TABLE table_name ADD column datatype [NULL|NOT NULL]
3  ALTER TABLE table_name ADD CONSTRAINT constraint_name {PRIMARY KEY|UNIQUE} (column_name)
5  ALTER TABLE table_name ALTER COLUMN column_name SET DATA TYPE datatype
?  ALTER TABLE table_name ALTER COLUMN column_name SET NOT NULL
  ALTER TABLE table_name ALTER column_name DROP NOT NULL
2  ALTER TABLE table_name DROP column_name
3  ALTER TABLE table_name DROP CONSTRAINT constraint_name
4  ALTER TABLE table_name RENAME COLUMN column_name TO new_column_name
3  CREATE [UNIQUE] INDEX index_name ON table_name
1  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL] [PRIMARY KEY] [UNIQUE])
3  DROP INDEX index_name
1  DROP TABLE table_name
4  TRUNCATE TABLE table_name

4  cas

Notes:
  The Applier processes the CREATE INDEX statement only if this statement creates an index in the same schema
as the parent table.

*** Greenplum
The Applier task can apply the following DDL operations to Greenplum targets:
2  ALTER TABLE table_name ADD column_name datatype [NULL]
3  ALTER TABLE table_name ADD CONSTRAINT constraint_name PRIMARY KEY (column_name)
?  ALTER TABLE table_name ALTER COLUMN column_name SET NOT NULL
5  ALTER TABLE table_name ALTER COLUMN column_name TYPE datatype
2  ALTER TABLE table_name DROP COLUMN column_name CASCADE
3  ALTER TABLE table_name DROP CONSTRAINT constraint_name CASCADE
3  CREATE INDEX index_name ON table_name (column_name)
1  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL]) DISTRIBUTED RANDOMLY
3  DROP INDEX index_name CASCADE
1  DROP TABLE table_name
4  TRUNCATE TABLE table_name

4  create table table_name as (select S_CHAR, count(*) as c_quantity from tablename S_CHAR )
4  rename column

Notes:
  For Oracle sources, Data Replication, by default, cannot replicate DROP CONSTRAINT operations that drop a
primary key. When extracting these DDL operations, the Extractor sets the NULL option on the primary key
columns. However, Greenplum does not support altering primary key columns. If you execute DROP
CONSTRAINT operations that drop a primary key on the source, set the apply.skip_alter_column_failed_ddl
runtime parameter to 0. This setting causes the Applier to not set the NULL option for the primary key columns on
the target. You can then set the NULL option for these columns manually.
  To replicate CREATE TABLE and ADD COLUMN operations to Greenplum targets in Audit Apply and Merge Apply
modes, you must specify table and column names in all lowercase on the source. If you use uppercase, the Applier
cannot replicate subsequent DML operations for the new table or column.    

*** MSSQL
The Applier task can apply the following DDL operations to Microsoft SQL Server targets:
2  ALTER TABLE table_name ADD column_name datatype [IDENTITY] [NULL|NOT NULL] [UNIQUE]
3  ALTER TABLE table_name ADD CONSTRAINT constraint_name PRIMARY KEY {CLUSTERED|NONCLUSTERED}
5  ALTER TABLE table_name ALTER COLUMN column_name datatype [NULL|NOT NULL]
2  ALTER TABLE table_name DROP COLUMN column_name
3  ALTER TABLE table_name DROP CONSTRAINT constraint_name
3  CREATE [UNIQUE] [CLUSTERED] INDEX index_name ON table_name (column_name)
1  CREATE TABLE table_name (column_name datatype [IDENTITY] [NULL|NOT NULL] [UNIQUE])
3  DROP INDEX index_name ON table_name
1  DROP TABLE table_name
4  SELECT * INTO new_table_name FROM existing_table_name
4  TRUNCATE TABLE table_name

Note:
Data Replication replicates RENAME COLUMN operations from Oracle sources to Microsoft SQL Server
targets as the following operation:
EXEC sp_rename 'table_name.[old_column_name]', 'new_column_name', 'COLUMN'

*** MySQL
The Applier task can apply the following DDL operations to MySQL targets:
2  ALTER TABLE table_name ADD column_name datatype [NULL|NOT NULL]
3  ALTER TABLE table_name ADD CONSTRAINT constraint_name PRIMARY KEY (column_name)
5  ALTER TABLE table_name ALTER column_name datatype [NULL|NOT NULL]
2  ALTER TABLE table_name DROP COLUMN column_name
3  ALTER TABLE table_name DROP PRIMARY KEY
  ALTER TABLE table_name MODIFY column_name datatype [NULL|NOT NULL]
3  CREATE [UNIQUE] INDEX index_name ON table_name (column_name);
1  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL] [PRIMARY KEY (column_name)])
3  DROP INDEX index_name ON table_name
1  DROP TABLE table_name

4  SELECT * INTO new_table_name FROM existing_table_name

Note:
Data Replication replicates TRUNCATE operations from sources to MySQL targets as DELETE FROM
operations.

*** Netezza
-- only 2 test
-- error in compare in first test
    
The Applier task can apply the following DDL operations to Netezza targets:
2  ALTER TABLE table_name ADD column_name datatype [NULL|NOT NULL]
  ALTER TABLE table_name ADD CONSTRAINT constraint_name UNIQUE (column_name)
2  ALTER TABLE table_name DROP COLUMN column_name CASCADE
  ALTER TABLE table_name DROP CONSTRAINT constraint_name CASCADE
  ALTER TABLE table_name MODIFY COLUMN column_name datatype
1  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL] [PRIMARY KEY (column_name)]) DISTRIBUTE ON {(column_name)|RANDOM}
1  DROP TABLE table_name

Notes:
  Data Replication does not replicate indexes that were created on a source database to Netezza targets because
Netezza does not use indexes.
  Data Replication does not replicate ALTER COLUMN operations that add NULL and NOT NULL constraints to a
source column to Netezza targets because Netezza does not support these types of DDL operations.
  Data Replication does not replicate ALTER COLUMN operations that modify a column datatype to Netezza targets
because Netezza does not support these types of DDL operations.
  Data Replication does not replicate ALTER COLUMN operations that modify the length of columns that have a
datatype other than VARCHAR to Netezza targets because Netezza does not support these types of DDL
operations.
  Data Replication does not replicate ADD COLUMN operations that add a column that has a NOT NULL constraint
but no default value from Oracle sources to Netezza targets. Netezza does not support these types of DDL
operations.
  Data Replication replicates TRUNCATE operations from sources to Netezza targets as DELETE FROM
operations.
  To replicate CREATE TABLE operation to Netezza targets, Data Replication creates a table on the target and
distributes data on the columns that are mapped to the primary key columns on the source. If the source table does
not have a primary key definition, Data Replication uses the DISTRIBUTE ON RANDOM clause.    

*** Oracle
The Applier task can apply the following DDL operations to Oracle targets:
2  ALTER TABLE table_name ADD (column_name datatype [CONSTRAINT constraint_name {NOT NULL|UNIQUE}]
3  ALTER TABLE table_name ADD CONSTRAINT constraint_name
2  ALTER TABLE table_name DROP (column_name)
3  ALTER TABLE table_name DROP CONSTRAINT constraint_name
3  ALTER TABLE table_name DROP {UNIQUE (column_name)|PRIMARY KEY}
5  ALTER TABLE table_name MODIFY (column_name datatype
4  ALTER TABLE table_name RENAME COLUMN column_name TO new_column_name
3  CREATE INDEX index_name ON table_name
1  CREATE TABLE table_name (column_name datatype [CONSTRAINT constraint_name {NOT NULL|UNIQUE}]
4  CREATE TABLE table_name AS SELECT statement
3  DROP INDEX index_name
1  DROP TABLE table_name
4  TRUNCATE TABLE table_name

Notes:
  When replicating DDL changes from Microsoft SQL Server sources to Oracle targets, Data Replication does not
replicate ALTER COLUMN operations that change a column datatype from VARCHAR(n) to VARCHAR(MAX).
Data Replication maps the SQL Server VARCHAR(MAX) datatype to the Oracle CLOB datatype, but Oracle does
not support an ALTER COLUMN operation that changes a VARCHAR column to a CLOB column.
  To replicate CREATE TABLE and ADD COLUMN operations to Oracle targets in Audit Apply and Merge Apply
modes, you must specify table and column names in all uppercase on the source. If you use lowercase, the Applier
cannot replicate subsequent DML operations for the new table or column.    

*** PostgreSQL
The Applier task can apply the following DDL operations to PostgreSQL targets:
2  ALTER TABLE table_name ADD column_name datatype
3  ALTER TABLE table_name ADD CONSTRAINT constraint_name [PRIMARY KEY|UNIQUE] (column_name)
5  ALTER TABLE table_name ALTER COLUMN column_name SET DATA TYPE datatype
?  ALTER TABLE table_name ALTER COLUMN column_name SET NOT NULL
2  ALTER TABLE table_name DROP COLUMN column_name CASCADE
3  ALTER TABLE table_name DROP CONSTRAINT constraint_name CASCADE
3  CREATE INDEX index_name ON table_name (column_name)
1  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL] [PRIMARY KEY (column_name))
3  DROP INDEX index_name CASCADE
1  DROP TABLE table_name
4  TRUNCATE table_name

4  create as select
4  rename

Note:
Data Replication does not enclose table names in quotes when replicating the TRUNCATE TABLE
operations. Consequently, the Applier ends abnormally when replicating the TRUNCATE TABLE statements for
the target tables that have case-sensitive names.    

*** SybaseASE
-- only 3 test
    
The Applier task can apply the following DDL operations to Sybase ASE targets:
2  ALTER TABLE table_name ADD column_name datatype [NULL|NOT NULL]
2  ALTER TABLE table_name DROP column_name
  ALTER TABLE table_name MODIFY column_name datatype [NULL|NOT NULL]
  CREATE INDEX index_name ON table_name (column_name)
1  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL]) LOCK DATAROWS
  DROP INDEX table_name.index_name
1  DROP TABLE table_name
  TRUNCATE TABLE table_name

3  Add primary key
3  Drop primary key

Note:
Data Replication does not replicate DDL operations that add a nullable BIT column from Microsoft SQL Server
sources to Sybase ASE targets because Sybase ASE does not support nullable BIT columns.    

*** Teradata
The Applier task can apply the following DDL operations to Teradata targets:
2  ALTER TABLE table_name ADD column_name datatype [NULL|NOT NULL]
b  ALTER TABLE table_name ADD CONSTRAINT constraint_name UNIQUE (column_name)
3  ALTER TABLE table_name DROP CONSTRAINT constraint_name
1  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL]) PRIMARY INDEX (column_name)
  CREATE UNIQUE INDEX index_name (column_name) ON table_name
  DROP INDEX index_name ON table_name
1  DROP TABLE table_name

4  create as select


Notes:
  Data Replication does not replicate ALTER TABLE operations that modify a source column datatype to Teradata
targets because Teradata does not support these types of DDL operations.
  Data Replication does not replicate DROP COLUMN operations for the source columns that are part of the primary
key. For source tables that do not have a primary key, Data Replication does not replicate DROP COLUMN
operations for the first column.
  Data Replication replicates TRUNCATE operations from sources to Teradata targets as DELETE ALL
operations.    

*** Vertica
-- only 1 test

The Applier task can apply the following DDL operations to Vertica targets:
  ALTER TABLE table_name ADD CONSTRAINT constraint_name {UNIQUE|PRIMARY KEY} (column_name)
  ALTER TABLE table_name DROP CONSTRAINT constraint_name CASCADE
  ALTER TABLE table_name ADD column_name datatype
  ALTER TABLE table_name DROP COLUMN column_name CASCADE
  ALTER TABLE table_name ALTER COLUMN column_name SET DEFAULT default_value
  ALTER TABLE table_name ALTER COLUMN column_name SET NOT NULL
  ALTER TABLE table_name ALTER COLUMN column_name SET DATA TYPE datatype
  ALTER TABLE table_name RENAME COLUMN column_name TO new_column_name
1  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL] [PRIMARY KEY (column_name)])
[SEGMENTED BY HASH (column_name) ALL NODES]
1  DROP TABLE table_name
  TRUNCATE TABLE table_name

Notes:
  The Applier ends abnormally when applying a source ADD column_name operation that has the NULL, NOT
NULL, or DEFAULT clause.
  Data Replication replicates ALTER COLUMN operations that change column datatypes only for target BINARY,
VARBINARY, CHAR, and VARCHAR columns that have no default values.    

** s2X
*** DB2
The Applier task can apply the following DDL operations to DB2 for Linux, UNIX, and Windows targets:
2  ALTER TABLE table_name ADD column datatype [NULL|NOT NULL]
n  ALTER TABLE table_name ADD CONSTRAINT constraint_name {PRIMARY KEY|UNIQUE} (column_name)
4  ALTER TABLE table_name ALTER COLUMN column_name SET DATA TYPE datatype
  ALTER TABLE table_name ALTER COLUMN column_name SET NOT NULL
n  ALTER TABLE table_name ALTER column_name DROP NOT NULL
  ALTER TABLE table_name DROP column_name
n  ALTER TABLE table_name DROP CONSTRAINT constraint_name
n  ALTER TABLE table_name RENAME COLUMN column_name TO new_column_name
3  CREATE [UNIQUE] INDEX index_name ON table_name
1  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL] [PRIMARY KEY] [UNIQUE])
3  DROP INDEX index_name
1  DROP TABLE table_name
4  TRUNCATE TABLE table_name

Notes:
  The Applier processes the CREATE INDEX statement only if this statement creates an index in the same schema
as the parent table.

*** Greenplum
!! no tests at all

The Applier task can apply the following DDL operations to Greenplum targets:
  ALTER TABLE table_name ADD column_name datatype [NULL]
  ALTER TABLE table_name ADD CONSTRAINT constraint_name PRIMARY KEY (column_name)
  ALTER TABLE table_name ALTER COLUMN column_name SET NOT NULL
  ALTER TABLE table_name ALTER COLUMN column_name TYPE datatype
  ALTER TABLE table_name DROP COLUMN column_name CASCADE
  ALTER TABLE table_name DROP CONSTRAINT constraint_name CASCADE
  CREATE INDEX index_name ON table_name (column_name)
  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL]) DISTRIBUTED RANDOMLY
  DROP INDEX index_name CASCADE
  DROP TABLE table_name
  TRUNCATE TABLE table_name

Notes:
  For Oracle sources, Data Replication, by default, cannot replicate DROP CONSTRAINT operations that drop a
primary key. When extracting these DDL operations, the Extractor sets the NULL option on the primary key
columns. However, Greenplum does not support altering primary key columns. If you execute DROP
CONSTRAINT operations that drop a primary key on the source, set the apply.skip_alter_column_failed_ddl
runtime parameter to 0. This setting causes the Applier to not set the NULL option for the primary key columns on
the target. You can then set the NULL option for these columns manually.
  To replicate CREATE TABLE and ADD COLUMN operations to Greenplum targets in Audit Apply and Merge Apply
modes, you must specify table and column names in all lowercase on the source. If you use uppercase, the Applier
cannot replicate subsequent DML operations for the new table or column.    

*** MSSQL
The Applier task can apply the following DDL operations to Microsoft SQL Server targets:
2  ALTER TABLE table_name ADD column_name datatype [IDENTITY] [NULL|NOT NULL] [UNIQUE]
n  ALTER TABLE table_name ADD CONSTRAINT constraint_name PRIMARY KEY {CLUSTERED|NONCLUSTERED}
4  ALTER TABLE table_name ALTER COLUMN column_name datatype [NULL|NOT NULL]
  ALTER TABLE table_name DROP COLUMN column_name
n  ALTER TABLE table_name DROP CONSTRAINT constraint_name
3  CREATE [UNIQUE] [CLUSTERED] INDEX index_name ON table_name (column_name)
1  CREATE TABLE table_name (column_name datatype [IDENTITY] [NULL|NOT NULL] [UNIQUE])
3  DROP INDEX index_name ON table_name
1  DROP TABLE table_name
n  SELECT * INTO new_table_name FROM existing_table_name
4  TRUNCATE TABLE table_name

Note:
Data Replication replicates RENAME COLUMN operations from Oracle sources to Microsoft SQL Server
targets as the following operation:
EXEC sp_rename 'table_name.[old_column_name]', 'new_column_name', 'COLUMN'

*** MySQL
-- no 4-th test

The Applier task can apply the following DDL operations to MySQL targets:
2  ALTER TABLE table_name ADD column_name datatype [NULL|NOT NULL]
n  ALTER TABLE table_name ADD CONSTRAINT constraint_name PRIMARY KEY (column_name)
5  ALTER TABLE table_name ALTER column_name datatype [NULL|NOT NULL]
2  ALTER TABLE table_name DROP COLUMN column_name
n  ALTER TABLE table_name DROP PRIMARY KEY
  ALTER TABLE table_name MODIFY column_name datatype [NULL|NOT NULL]
3  CREATE [UNIQUE] INDEX index_name ON table_name (column_name);
1  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL] [PRIMARY KEY (column_name)])
3  DROP INDEX index_name ON table_name
1  DROP TABLE table_name

Note:
Data Replication replicates TRUNCATE operations from sources to MySQL targets as DELETE FROM
operations.

*** Netezza
The Applier task can apply the following DDL operations to Netezza targets:
2  ALTER TABLE table_name ADD column_name datatype [NULL|NOT NULL]
n  ALTER TABLE table_name ADD CONSTRAINT constraint_name UNIQUE (column_name)
2  ALTER TABLE table_name DROP COLUMN column_name CASCADE
n  ALTER TABLE table_name DROP CONSTRAINT constraint_name CASCADE
5  ALTER TABLE table_name MODIFY COLUMN column_name datatype
1  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL] [PRIMARY KEY (column_name)]) DISTRIBUTE ON {(column_name)|RANDOM}
1  DROP TABLE table_name

Notes:
  Data Replication does not replicate indexes that were created on a source database to Netezza targets because
Netezza does not use indexes.
  Data Replication does not replicate ALTER COLUMN operations that add NULL and NOT NULL constraints to a
source column to Netezza targets because Netezza does not support these types of DDL operations.
  Data Replication does not replicate ALTER COLUMN operations that modify a column datatype to Netezza targets
because Netezza does not support these types of DDL operations.
  Data Replication does not replicate ALTER COLUMN operations that modify the length of columns that have a
datatype other than VARCHAR to Netezza targets because Netezza does not support these types of DDL
operations.
  Data Replication does not replicate ADD COLUMN operations that add a column that has a NOT NULL constraint
but no default value from Oracle sources to Netezza targets. Netezza does not support these types of DDL
operations.
  Data Replication replicates TRUNCATE operations from sources to Netezza targets as DELETE FROM
operations.
  To replicate CREATE TABLE operation to Netezza targets, Data Replication creates a table on the target and
distributes data on the columns that are mapped to the primary key columns on the source. If the source table does
not have a primary key definition, Data Replication uses the DISTRIBUTE ON RANDOM clause.    

*** Oracle
-- only 3 test

The Applier task can apply the following DDL operations to Oracle targets:
2  ALTER TABLE table_name ADD (column_name datatype [CONSTRAINT constraint_name {NOT NULL|UNIQUE}]
n  ALTER TABLE table_name ADD CONSTRAINT constraint_name
2  ALTER TABLE table_name DROP (column_name)
n  ALTER TABLE table_name DROP CONSTRAINT constraint_name
  ALTER TABLE table_name DROP {UNIQUE (column_name)|PRIMARY KEY}
  ALTER TABLE table_name MODIFY (column_name datatype
n  ALTER TABLE table_name RENAME COLUMN column_name TO new_column_name
3  CREATE INDEX index_name ON table_name
1  CREATE TABLE table_name (column_name datatype [CONSTRAINT constraint_name {NOT NULL|UNIQUE}]
n  CREATE TABLE table_name AS SELECT statement
3  DROP INDEX index_name
1  DROP TABLE table_name
  TRUNCATE TABLE table_name

Notes:
  When replicating DDL changes from Microsoft SQL Server sources to Oracle targets, Data Replication does not
replicate ALTER COLUMN operations that change a column datatype from VARCHAR(n) to VARCHAR(MAX).
Data Replication maps the SQL Server VARCHAR(MAX) datatype to the Oracle CLOB datatype, but Oracle does
not support an ALTER COLUMN operation that changes a VARCHAR column to a CLOB column.
  To replicate CREATE TABLE and ADD COLUMN operations to Oracle targets in Audit Apply and Merge Apply
modes, you must specify table and column names in all uppercase on the source. If you use lowercase, the Applier
cannot replicate subsequent DML operations for the new table or column.    

*** PostgreSQL
-- no 4-th test
    
The Applier task can apply the following DDL operations to PostgreSQL targets:
2  ALTER TABLE table_name ADD column_name datatype
n  ALTER TABLE table_name ADD CONSTRAINT constraint_name [PRIMARY KEY|UNIQUE] (column_name)
5  ALTER TABLE table_name ALTER COLUMN column_name SET DATA TYPE datatype
  ALTER TABLE table_name ALTER COLUMN column_name SET NOT NULL
2  ALTER TABLE table_name DROP COLUMN column_name CASCADE
n  ALTER TABLE table_name DROP CONSTRAINT constraint_name CASCADE
3  CREATE INDEX index_name ON table_name (column_name)
1  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL] [PRIMARY KEY (column_name))
3  DROP INDEX index_name CASCADE
1  DROP TABLE table_name
  TRUNCATE table_name

4 create as select


Note:
Data Replication does not enclose table names in quotes when replicating the TRUNCATE TABLE
operations. Consequently, the Applier ends abnormally when replicating the TRUNCATE TABLE statements for
the target tables that have case-sensitive names.    

*** SybaseASE
-- only 1 test

The Applier task can apply the following DDL operations to Sybase ASE targets:
  ALTER TABLE table_name ADD column_name datatype [NULL|NOT NULL]
  ALTER TABLE table_name DROP column_name
  ALTER TABLE table_name MODIFY column_name datatype [NULL|NOT NULL]
  CREATE INDEX index_name ON table_name (column_name)
1  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL]) LOCK DATAROWS
  DROP INDEX table_name.index_name
1  DROP TABLE table_name
  TRUNCATE TABLE table_name

Note:
Data Replication does not replicate DDL operations that add a nullable BIT column from Microsoft SQL Server
sources to Sybase ASE targets because Sybase ASE does not support nullable BIT columns.    

*** Teradata
The Applier task can apply the following DDL operations to Teradata targets:
  ALTER TABLE table_name ADD column_name datatype [NULL|NOT NULL]
n  ALTER TABLE table_name ADD CONSTRAINT constraint_name UNIQUE (column_name)
n  ALTER TABLE table_name DROP CONSTRAINT constraint_name
d  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL]) PRIMARY INDEX (column_name)
3  CREATE UNIQUE INDEX index_name (column_name) ON table_name
3  DROP INDEX index_name ON table_name
d  DROP TABLE table_name

Notes:
  Data Replication does not replicate ALTER TABLE operations that modify a source column datatype to Teradata
targets because Teradata does not support these types of DDL operations.
  Data Replication does not replicate DROP COLUMN operations for the source columns that are part of the primary
key. For source tables that do not have a primary key, Data Replication does not replicate DROP COLUMN
operations for the first column.
  Data Replication replicates TRUNCATE operations from sources to Teradata targets as DELETE ALL
operations.    

*** Vertica
The Applier task can apply the following DDL operations to Vertica targets:
n  ALTER TABLE table_name ADD CONSTRAINT constraint_name {UNIQUE|PRIMARY KEY} (column_name)
n  ALTER TABLE table_name DROP CONSTRAINT constraint_name CASCADE
2  ALTER TABLE table_name ADD column_name datatype
2  ALTER TABLE table_name DROP COLUMN column_name CASCADE
n  ALTER TABLE table_name ALTER COLUMN column_name SET DEFAULT default_value
  ALTER TABLE table_name ALTER COLUMN column_name SET NOT NULL
  ALTER TABLE table_name ALTER COLUMN column_name SET DATA TYPE datatype
n  ALTER TABLE table_name RENAME COLUMN column_name TO new_column_name
1  CREATE TABLE table_name (column_name datatype [NULL|NOT NULL] [PRIMARY KEY (column_name)])
[SEGMENTED BY HASH (column_name) ALL NODES]
1  DROP TABLE table_name
5  TRUNCATE TABLE table_name

Notes:
  The Applier ends abnormally when applying a source ADD column_name operation that has the NULL, NOT
NULL, or DEFAULT clause.
  Data Replication replicates ALTER COLUMN operations that change column datatypes only for target BINARY,
VARBINARY, CHAR, and VARCHAR columns that have no default values.    

* Fanout
** Test case:
  с мсскл в качестве сорса, на сане и линуксе, используя расшаренные папки с бекапами,
  нужно собрать фанаутные конфигурации и попробовать отреплицироваться.
  поддерживаемые ДДЛ, для гринплама и постгреса.
  
  for SM: source on main, targets on main and another subserver.
  All datatypes, DDL.
  
  SM1, Extractor, Applier on SUN (10.51.40.50:18030)
  SM2, Applier, on SUN (10.51.40.47:18030)
  Source: MS SQL Server 2008 EE - offline logs (10.51.4.112)
  Target1: GREENPLUM (10.51.40.116 qa_gp01 dest\test public)
  Target2: GREENPLUM (10.51.40.116 qa_gp01 dest\test target)
** DevTrack
  INFA349702 - MSSQL Extract crashed on sun with SIGBUS error (unalligned access)
  MSSQL Extractor ends with failure when reads offline backup log files on SUN.
  Cause of the error - an incorrect alignment in the statement
  endOfLastRof  = reinterpret_cast(this->VarDataPtr) + sizeof(rof_descriptor) + (rofDscr->level == 0x0100 ? 12 : 0);
  Tested revision 28337.
* Other
Timur Shalafaev - GUI
Alexey Chadaev - SM

  
;; Change the file name under which the current buffer will be saved.  
(set-visited-file-name)

Visit a different file instead of the one visited last
`C-x C-v'

dired current file folder
C-x C-j

;; when resize windows/buffer size, resizes text
;(visual-line-mode)

;; setting left/righr fringes
;(fringe-mode)

(setq visible-bell t)

(setq echo-keystrokes 0.1)
