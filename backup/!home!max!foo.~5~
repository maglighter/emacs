Git.
file status can be: untracked -> unmodified -> modified -> staged (index)
.gitignore - file that contain names of files, globs which wouldn't be included in repository
create repository:
  git init
add file to version control & indexing changes (add to staged | update):
  git add <file>
status of each file in rep. (changed/unchanged/untracked), branch:
  git status
compare changed files
  git diff [--staged - diff indexed files]
make snapshot of indexed files 
  git commit [-a - without 'git add' for changed files] [-m ' ' - info]
delete file from index and from working dir:
  git rm [--cached - delete only from index]
move file
  git mv <source> <target>
view commites log:
  git log [-p - show diff] [-2 - number of records]

Regexp.
.  - один произвольный символ, кроме \n
*  - нуль или более повторений предшествующего символа
+  - одно или более повторений предшествующего символа
?  - предшествующий элемент не является обязательным
.* - нуль или более повторений любых символов
() - группировка элементов выражения. (qe)+ = qeqeqe...

Grep.
Ищет все слова, начинающиеся с use, в текущей папке, среди всех файлов:
grep 'use.*' *
grep '^#.*\.$' /etc/fstab

Perl.
Каждая строка файла links передается в команду wget; $_ - дефолтный счетчик:
perl -ne 'system("wget $_")' buf
perl -e 'chomp(@file = <STDIN>); foreach (@file) { system("wget $_") }' < links
Здесь тоже самое, в wget передается сразу весь массив @file в одну строку:
perl -e 'chomp(@file = <STDIN>); system("wget @file")' < links
Опции командной строки:
-n - сгенирировать код: while (<>) { ... }
-p - сгенирировать код: while (<>) { ... print; }
-i~ - создание бекапа и обновление файла, без бекапа - -i
-w - выводить предупреждения
-e - далее следует исполняемый код ''

Emacs.
Список всех привязок
M-x describe-bindings
---
Запись макроса:
  С-x (, F3
Конец записи макроса:
  C-x ), F4
Выполнение:
  C-x e (повтрорно е), F4
Редактирование макроса:
  edit-kbd-macro (C-x C-k e)
Применение макроса только для части текста:
  C-x C-k r

Calc.
C-x * c | C-x * * - запуск в обычном режиме
C-x * q - quick mode
C-x * k - запуск в режиме keypad
C-x * 0 - reset
h k <com> - справка по команде
h f <fun> - справка по функции
h s - все клавиатурные привязки
C-x * g - grab, копирует матрицу из буффера, и пересылает в одну строку
C-x * r - копирует матрицу
C-x * y - вставляет значение из вершины стека в буфер
C-x * : - grab the rectangular region and compute the sums of its columns
C-x * _ - grab the rectangular region and compute the sums of its rows
m a - algebraic mode
d B - big screen mode
s s - сохраняет значение вершины стека в веденную переменную
s k - сохраняет значение вершины стека в веденную переменную и удаляет её
M-0-9 d f - округляет до заданного числа знаков
d g - разделяет число запятыми
= - разворачивает переменные в вершине стека
U - undo
D - redo
d 1 - 10, d 6 - 16, d 8 - 8; 2#101011, 16#0xA2B

Aptitude.
Установка:
  sudo aptitude install package[s]
Переустановка:
  sudo aptitude reinstall package[s]
Удаление пакета с сохранением настроек:
  sudo aptitude remove package[s]
Очистка настроек пакета:
  sudo aptitude purge package[s]
Показывает информацию о пакете:
  aptitude show package
Выводит пакеты, в названии или описании которых есть keyword:
  aptitude search keyword
Вывод. Левые столбцы:
    i (от installed) - пакет установлен в системе:
    p (от purge) - пакет не был установлен или был удален "вчистую";
    c (от clean) - пакет, удаленный с сохранением конфигурационных файлов;
    v (от virtual) - т.н. виртуальные пакеты, то есть просто списки реальных пакетов, один из которых будет использоваться в той или иной ситуации.
    A (от Auto) - пакет был установлен не самостоятельно, а автоматически, как зависимость другого пакета;
    h (от hold) - для пакета зафиксирована его текущая версия, то есть он не будет обновляться при выполнении операторов upgrade и dist-upgrade (см. ниже);
    u (от unpacked) - пакет был получен, распакован, но не инкорпорирован в файловую систему и не сконфигурирован;
    C (от half-Configured) - пакет, установка которого оборвалась на стадии конфигурирования;
    H (от Half-installed) - пакет, установка которого оборвалась на стадии инсталляции;
    B (от Broken) - т.н. "сломанные" пакеты - то есть содержащие ошибки внутри себя или утратившие свои зависимости.
Обновляет список пакетов:
  sudo aptitude update
Обновление всех пакетов:
  sudo aptitude upgrade

Компиляция/Compile:
  ./configure
  make
  checkinstall
  sudo dpkg -i package_name.deb

Синхронизация времени:
  sudo ntpdate-debian

Создание zip архива:
  zip -r -9 name.zip dir1 file1 dir2 file2

Делаем файл исполняемым:
  chmod +x file

WIN API compile and link:
  i586-mingw32msvc-gcc start.c -o start.exe
For run in windows: 
  i586-mingw32msvc-gcc -mwindows api.cpp -o api.exe
The project compilation: 
  i586-mingw32msvc-gcc rctm.cpp resource.h
If there is a *.rc file (resource script):
  i586-mingw32msvc-windres rctm.rc rctmrc.o
  i586-mingw32msvc-gcc -mwindows resource.h rctm.o rctmrc.o -o timer.exe

GDB.
Точка останова:
  (b)reak [точка | функция]
Установка точки наблюдения (программа остановится, когда переменная изменится):
  watch [перем]
Удаление точк(и/eк) останова:
  delete [точк(а/и)]
Информация о точке останова:
  info breakpoints
Запуск программы (выполнение программы с самого начала):
  (r)un
Информация о выполненных командах и функциях:
  (b)ack(t)race
Вывод переменной один раз:
  (p)rint [перем]
Вывод переменной на каждом шаге:
  display [перем]
Выполнение одного шага и возврат управления отладчику:
  (s)tep [число шагов]
Выполнение одного шага без перехода к какой-либо ф-ии:
  (n)ext [число шагов]
Пропускает функцию и выводит ее возвращаемое значение:
  finish
Продолжить выполнение программы (можно предварительно добавить еще
одну точку останова в другое место программы):
  (c)ontinue
Устанавливает значение для какой-либо переменной:
  set j=5
Прерывание любой выполняющейся команды и возвращение в gdb:
  C-c

MONO:
  gmcs hello.cs
  gmcs hello.cs -pkg:dotnet
  mono hello.exe

Рекурсивно скачивает все страницы на 2 уровня:
  wget -r -l 2 http://vsokovikov.narod.ru/New_MSDN_API/Process_thread/ogl_process.htm

Конвертирование файла из WINDOWS-1251(ANSI) в UTF-8:
  iconv -f WINDOWS-1251 -t UTF-8 X3.txt > X3_new.txt
Emacs:
  C-x <RET> f utf-8-unix

Genisoimage.
Позволяет создавать следующие типы ISO-образов:
Загрузочные (boot).
С расширениями Rock Ridge. Эти расширения предназначены для операционных систем семейства Linux, а именно для работы прав доступа пользователей.
С расширениями Joliet. Joliet-расширения не являются частью стандарта ISO9660. Эти расширения, в основном, используются в ОС Windows при записи дисков. Характерным для Joliet-расширений является: unicode-имена файлов и директорий, длина одного компонента пути может быть до 64 unicode-символов. 

Создание образа:
  genisoimage -iso-level 4 -J -o myimage.iso ~/music
    	-iso-level 4 указывает не накладывать ограничения на длину имени файла и вложенность директорий.
    	-J указывает использовать Joliet-расширения (если диск будет использоваться на ОС Windows).
    	-o задаёт имя конечного образа.
    	~/music задаёт папку, которая будет рекурсивно включена в образ.

Растягивает игры с разрешением 800х600 на весь экран:
  xrandr --output LVDS1 --set "scaling mode" "Full"
Наоборот:
  xrandr --output LVDS1 --set "scaling mode" "Full aspect"
Wine msi:
  wine msiexec /i whatever.msi
	
VirtualBox:
sudo aptitude install linux-headers-2.6-$(uname -r|sed 's,[^-]*-[^-]*-,,') virtualbox-ose


Turn on internet from the shel:
  iwconfig wlan0 essid Light
  dhclient wlan0

ip:192.168.0.100

dconf write /org/gnome/desktop/interface/gtk-theme '"HighContrast"' && dconf write /org/gnome/desktop/interface/gtk-theme '"MediterraneanDark"'


Emacs Lisp.

eval-last-sexp
	Вычислить последнее символическое выражение перед текущим
    положением курсора. Возвращенное значение будет напечатано в эхо-области,
    если эта функция запущена без префикс-аргумента; если функция запущена с
    префикс-аргументом, то результат печатается в текущем буфере. Эта команда
    обычно привязана к сочетанию клавиш C-x C-e.

defun
	Define function (Определить функцию). Эта особая форма может включать
    до пяти частей --- имя, шаблон для аргументов, передаваемых в функцию,
    необязательную документацию, необязательное интерактивное объявление, и
    само тело функции. Например:
    
    (defun back-to-indentation ()
      "Переместить точку к первому видимому символу на линии."
      (interactive)
      (beginning-of-line 1)
      (skip-chars-forward " \t"))

interactive
	Объявить интерпретатору, что эта функция может использоваться
    интерактивно. За этой особой формой может следовать строка, состоящая из
    нескольких частей, о том, как передать информацию в эту функцию. В этой
    строке могут так же содержаться подсказки отображаемые в
    эхо-области. Части строки разделяются друг от друга символами новой
    строки `\n'.

    Наиболее часто используемые символы:

    b Имя существующего буфере.

    f Имя существующего файла.

    p Числовой префикс-аргумент. (Обратите внимание, что `p' набран в нижнем
      регистре).  r Точка и метка, как два числовых аргумента, самое
      маленькое первым. Это единственный символ, который сразу описывает
      два последовательных аргумента, а не один.

        See section `Code Characters for `interactive'' in The GNU Emacs Lisp
    Reference Manual, для более полного списка символов, предопределенных для
    interactive.

let
	Объявляет список переменных, которые будут использоваться внутри тела
    let, и присваивает им первоначальные значения, или nil или заданное
    программистом; затем вычисляет оставшиеся выражения в теле let и
    возвращает результат вычисления последнего из них. Внутри тела let
    интерпретатор Лиспа игнорирует переменные с теми же именами, которые
    существуют вне выражения let. Например:
    
    (let ((foo (buffer-name)) (bar (buffer-size))) (message "В этом буфере %s
        ровно %d characters."  foo bar))

save-excursion
	Запоминает значение точки, метки и текущего буфера перед
    вычислением тела этой особой формы. Затем восстанавливает их значения к
    первоначальным. Например:
    
    (message "Мы на расстоянии %d символов от начала буфера."  (- (point)
        (save-excursion (goto-char (point-min)) (point))))

if
	Вычисляет первый аргумент особой формы; если результат --- истинна,
    вычисляет второй аргумент; иначе вычисляет третий аргумент, если он
    существует.
	Особая форма if называется условной формой. В Emacs Лиспе существуют и
    другие условные формы, но if наиболее часто используемая. Например:
    
    (if (string= (int-to-string 19) (substring (emacs-version) 10 12))
	(message "Это 19 версия Emacs") (message "Это не 19 версия
             Emacs"))

equal
eq
	Проверяют два объекта на равенство. equal возвращает истину если два
    объекта имеют одинаковую структуру и содержание. Другая функция eq
    возвращает истину, если два аргумента на самом деле один и тот же объект.

< > <= >=
    Функция < проверяет, меньше ли ее первый аргумент чем второй.
Соответственно функция > проверяет больше ли ее первый аргумент чем
второй. <= проверяет меньше или равен первый аргумент второго и >=
соответственно больше либо равен первый аргумент второму. Эти функции
работают только с численными аргументами.

message
	Печатает сообщение в эхо-области. Длина сообщения ограничена только
    одной строкой. Первый аргумент --- это строка, которая может содержать
    символы `%s', `%d', `%c', на месте которых будут подставлены последующие
    аргументы функции message. Аргумент, подставляемый на место `%s', должен
    быть строкой или символом; на место `%d' подставляется число. Аргумент,
    который используется с `%c' тоже должен быть числом, оно будет напечатано
    как код для ASCII символа.

setq
set
	Функция setq устанавливает значением своего первого аргумента
    значение второго аргумента. Первый аргумент setq не вычисляется
    автоматически. Эту функцию можно использовать и сразу с несколькими
    аргументами. Другая функция set принимает только два аргумента, и после
    вычисления обоих назначает значению, возвращенному первым аргументом,
    значение, возвращенное вычислением второго аргумента.

buffer-name
	Используется без аргумента, возвращает имя буфера в виде строки.

buffer-file-name
	Используется без аргумента, возвращает имя файла, связанного с данным
    буфером.

current-buffer
	Возвращает текущий активный буфер Emacs --- это необязательно должен
    быть буфер, который отображен на экране.

other-buffer
	Возвращает недавно выбранный буфер.

switch-to-buffer
	Устанавливает буфер, который задан как аргумент активным для
    Emacs и одновременно отображает его в текущем окне. Обычно эта команда
    связана с C-x b.

set-buffer
	Переключает внимание Emacs на другой буфер. Не изменяет содержимое
    текущего окна Emacs.

buffer-size
	Возвращает число символов в текущем буфере.

point
	Возвращает значение текущей позиции курсора как целое, считая число
    символов с начала буфера.

point-min
	Возвращает минимально возможное значение точки в текущем
    буфере. Обычно 1, если не включено сужение.

point-max
	Возвращает максимально возможное значение точки в текущем
    буфере. Обычно конец буфера, если не включено сужение.

Карта № 2938494461    
Теневая экономика в современных условиях: сущность, причины, масштаб, пути регулирования
4:0:5:1:3:2:9:2:3:2:7:0:2:4:7:2:2:0:3:0:2:7:9:2:1:8:0:1:1:5:1:1:1:7:3:1:2:9:7:0

pap: k5l0n3v1m5m0r3s1

ankii:
disere - желание
sequence
ubiquitous
various
involved
beyond
thereby
retrieve
route
negotiate
reside
privacy
statement
enterprise
allocate
scarce
beneficial
election
crews
scheduling
exhibit
challenge
facilitate
encounter
certain
overall
bounded
wisely,
roughly
impact
approach
permutation
employ
essence
held
composedunits

dereferencing - разыменование = indirection - косвенное обращение
